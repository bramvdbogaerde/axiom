%% This file tests HaskellExpr parsing and execution functionality

syntax {
    a, result, sum, product in Int;
    test in Rules ::= t(result, result);
};

rules {
    rule "Simple-HaskellExpr"
    [ ] =>
    [ t(result, ${42}) ];
    
    rule "Arithmetic-HaskellExpr"
    [ ] =>
    [ t(result, ${10 + 5}) ];

    %% TODO: this is only works when the
    %% Haskell expression that references variables
    %% from the antecedents is the last goal in the
    %% antecedent list. However the order of goals such
    %% not be important to the result of the queries,
    %% to solve this a dependency graph should be constructed so that the Haskell expression is always the last goal (cf. design.md). 
    rule "Var-Access"
    [ a = 5 ; product = ${a * 2} ] =>
    [ t(result, product) ];
    
    rule "Complex-Arithmetic"
    [ ] =>
    [ t(result, ${6 * 7 + 2}) ];
};

%% Test queries to verify Haskell expressions execute correctly
%codegen_test: t(result, 42)
%codegen_test: t(sum , 15)
%codegen_test: t(product, 44)
%codegen_test: t(result, 10)
