%% This file tests HaskellExpr parsing and execution functionality

{{{
import Data.Maybe
}}}

syntax {
    a, result, sum, product in Int;
    test in Rules ::= t(result);
};

rules {
    rule "Simple-HaskellExpr"
    [ ] =>
    [ t(${42}) ];
    
    rule "Arithmetic-HaskellExpr"
    [ ] =>
    [ t(${10 + 5}) ];

    %% TODO: this is only works when the
    %% Haskell expression that references variables
    %% from the antecedents is the last goal in the
    %% antecedent list. However the order of goals such
    %% not be important to the result of the queries,
    %% to solve this a dependency graph should be constructed so that the Haskell expression is always the last goal (cf. design.md). 
    rule "Var-Access"
    [ a = 5 ; product = ${a * 2} ] =>
    [ t(product) ];
    
    rule "Complex-Arithmetic"
    [ ] =>
    [ t(${6 * 7 + 2}) ];
};

%% Test queries to verify Haskell expressions execute correctly
%codegen_test: t(42)
%codegen_test: t(15)
%codegen_test: t(44)
%codegen_test: t(10)
