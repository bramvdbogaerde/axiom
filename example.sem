% Comments

%% Syntax

syntax {
	%% Expressions
	aexp in AExp ::= i | lambda(x, e);
	e in Exp ::= aexp
			   | let(x, e, e);
	i in Int;
	x in Atom;

	%% Values
	v in Value ::= closure(aexp, rho);

	%% State space

	rho  in Environment;
	sto  in Store;
	k, kont in Stack;

	ctrl in Ctrl ::= ev(e, rho)
				   | ap(v);

	state in State ::= st(ctrl, kont, sto);
		
};

%% Rewrite functions

aeval(lambda(x, e), rho, sto) =
	closure(lambda(x,e), rho);
aeval(i, rho, sto) = i;


%% Declare the main transition function between two sequential states
transition State ~> State;

%% Transition rules

rules {
	
	rule "St-Atomic"
	[ aeval(aexp, rho, sto) = v ]
	=>
	[
		st(ev(aexp, rho), k, sto)
	~>  st(ap(v), k, sto)
	];

%	rule "St-App"
%	[ aeval(aexp0, rho, sto) = closure(lambda(x, e), rho1);
%	  aeval(aexp1, rho, sto) = v1;
%	  adr  = alloc(x);
%	  rho2 = extend(rho1, x, adr);
%	  sto2 = extend(sto,  adr, v1) ]
%	=>
%	[
%		st(ev(app(aexp0, aexp1), rho), k, sto)
%	~>  st(ev(e, rho2), k, sto2)
%	];

};
